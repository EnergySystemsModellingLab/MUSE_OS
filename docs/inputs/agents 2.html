
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agents &#8212; MUSE Documentation 0.8 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Correlation demand files" href="correlation_files.html" />
    <link rel="prev" title="Existing Sectoral Capacity" href="existing_capacity.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="correlation_files.html" title="Correlation demand files"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="existing_capacity.html" title="Existing Sectoral Capacity"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MUSE Documentation 0.8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Input Files</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="inputs_csv.html" accesskey="U">Input Files</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Agents</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="agents">
<span id="inputs-agents"></span><h1>Agents<a class="headerlink" href="#agents" title="Permalink to this headline">¶</a></h1>
<p>In MUSE, an agent-based formulation was originally introduced for the residential and
commercial building sectors <span class="bibtex" id="id1">[2019:sachs]</span>.  Agents are defined using a CSV file, with
one agent per row, using a somewhat historical format meant specifically for retrofit
and new-capacity agent pairs. This CSV file can be read using
<a class="reference internal" href="../source/muse.readers.html#muse.readers.csv.read_csv_agent_parameters" title="muse.readers.csv.read_csv_agent_parameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv_agent_parameters()</span></code></a>. The data is also
interpreted to some degree in the factory functions
<code class="xref py py-func docutils literal notranslate"><span class="pre">create_retrofit_agent()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">create_newcapa_agent()</span></code>.</p>
<p>For instance, we have the following CSV table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>AgentShare</p></th>
<th class="head"><p>RegionName</p></th>
<th class="head"><p>Objective1</p></th>
<th class="head"><p>SearchRule</p></th>
<th class="head"><p>DecisionMethod</p></th>
<th class="head"><p>…</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A1</p></td>
<td><p>New</p></td>
<td><p>Agent5</p></td>
<td><p>ASEAN</p></td>
<td><p>EAC</p></td>
<td><p>all</p></td>
<td><p>epsilonCon</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>A4</p></td>
<td><p>New</p></td>
<td><p>Agent6</p></td>
<td><p>ASEAN</p></td>
<td><p>CapitalCosts</p></td>
<td><p>existing</p></td>
<td><p>weightedSum</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>A1</p></td>
<td><p>Retrofit</p></td>
<td><p>Agent1</p></td>
<td><p>ASEAN</p></td>
<td><p>efficiency</p></td>
<td><p>all</p></td>
<td><p>epsilonCon</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>A2</p></td>
<td><p>Retrofit</p></td>
<td><p>Agent2</p></td>
<td><p>ASEAN</p></td>
<td><p>Emissions</p></td>
<td><p>similar</p></td>
<td><p>weightedSum</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
<p>For simplicity, not all columns are included in the example above. Though all column
listed below are currently required.</p>
<p>The columns have the following meaning:</p>
<dl class="simple" id="name">
<dt>Name</dt><dd><p>Name shared by a retrofit and new-capacity agent pair.</p>
</dd>
<dt>Type</dt><dd><p>One of “New” or “Retrofit”. “New” and “Retrofit” agents make up a pair with a given
<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>. The demand is split into two, with one part coming from
decommissioned assets, and the other coming from everything else. “Retrofit” agents
invest only to make up for decommissioned assets. They are often limited in the
technologies they can consider (by <a class="reference internal" href="#searchrule"><span class="std std-ref">SearchRule</span></a>). “New” agents
invest on the rest of the demand, and can often consider more general sets of
technologies.</p>
</dd>
<dt>AgentShare</dt><dd><p>Name of the share of the existing capacity assigned to this agent. Only meaningful
for retrofit agents. The actual share itself can be found in
<a class="reference internal" href="technodata.html#inputs-technodata"><span class="std std-ref">Techno-data</span></a>.</p>
</dd>
<dt>RegionName</dt><dd><p>Region where an agent operates.</p>
</dd>
</dl>
<dl id="objective1">
<dt>Objective1</dt><dd><p>First objective that an agent will try and maximize or minimize during investment.
This objective should be one registered with
<a class="reference internal" href="../source/muse.html#muse.objectives.register_objective" title="muse.objectives.register_objective"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;register_objective</span></code></a>. The following objectives are
available with MUSE:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.comfort" title="muse.objectives.comfort"><code class="xref py py-func docutils literal notranslate"><span class="pre">comfort</span></code></a>: Comfort provided by a given technology. Comfort does
not change during the simulation. It is obtained straightforwardly from
<a class="reference internal" href="technodata.html#inputs-technodata"><span class="std std-ref">Techno-data</span></a>.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.efficiency" title="muse.objectives.efficiency"><code class="xref py py-func docutils literal notranslate"><span class="pre">efficiency</span></code></a>: Efficiency of the technologies. Efficiency does
not change during the simulation. It is obtained straightforwardly from
<a class="reference internal" href="technodata.html#inputs-technodata"><span class="std std-ref">Techno-data</span></a>.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.fixed_costs" title="muse.objectives.fixed_costs"><code class="xref py py-func docutils literal notranslate"><span class="pre">fixed_costs</span></code></a>: The fixed maintenance costs incurred by a
technology. The costs are a function of the capacity required to fulfil the current
demand.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.capital_costs" title="muse.objectives.capital_costs"><code class="xref py py-func docutils literal notranslate"><span class="pre">capital_costs</span></code></a>: The capital cost incurred by a
technology. The capital cost does not change during the simulation. It is obtained
as a function of parameters found in <a class="reference internal" href="technodata.html#inputs-technodata"><span class="std std-ref">Techno-data</span></a>.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.emission_cost" title="muse.objectives.emission_cost"><code class="xref py py-func docutils literal notranslate"><span class="pre">emission_cost</span></code></a>: The costs associated for emissions for a
technology. The costs is a function both of the amount produced (equated to the
total demand in this case) and of the prices associated with each pollutant.
Aliased to “emission” for simplicity.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.fuel_consumption_cost" title="muse.objectives.fuel_consumption_cost"><code class="xref py py-func docutils literal notranslate"><span class="pre">fuel_consumption_cost</span></code></a>: Costs of the fuels for
each technology, where each technology is used to fulfil the whole demand.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.lifetime_levelized_cost_of_energy" title="muse.objectives.lifetime_levelized_cost_of_energy"><code class="xref py py-func docutils literal notranslate"><span class="pre">lifetime_levelized_cost_of_energy</span></code></a>:
LCOE over the lifetime of a technology. Aliased to “LCOE” for simplicity.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.net_present_value" title="muse.objectives.net_present_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">net_present_value</span></code></a>: Present value of all the costs of
installing and operating a technology, minus its revenues, of the course of its
lifetime. Aliased to “NPV” for simplicity.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.objectives.equivalent_annual_cost" title="muse.objectives.equivalent_annual_cost"><code class="xref py py-func docutils literal notranslate"><span class="pre">equivalent_annual_cost</span></code></a>: Annualized form of the
net present value. Aliased to “EAC” for simplicity.</p></li>
</ul>
<p>The weight associated with this objective can be changed using <a class="reference internal" href="#objdata1"><span class="std std-ref">ObjData1</span></a>.  Whether the objective should be minimized or maximized depends on
<a class="reference internal" href="#objsort1"><span class="std std-ref">Objsort1</span></a>. Multiple objectives are combined using the
<a class="reference internal" href="#decisionmethod"><span class="std std-ref">DecisionMethod</span></a></p>
</dd>
</dl>
<dl class="simple" id="objective2">
<dt>Objective2</dt><dd><p>Second objective. See <a class="reference internal" href="#objective1"><span class="std std-ref">Objective1</span></a>.</p>
</dd>
</dl>
<dl class="simple" id="objective3">
<dt>Objective3:</dt><dd><p>Third objective. See <a class="reference internal" href="#objective1"><span class="std std-ref">Objective1</span></a>.</p>
</dd>
</dl>
<dl class="simple" id="objdata1">
<dt>ObjData1</dt><dd><p>A weight associated with the <a class="reference internal" href="#objective1"><span class="std std-ref">first objective</span></a>. Whether it is used
will depend in large part on the <a class="reference internal" href="#decisionmethod"><span class="std std-ref">decision method</span></a>.</p>
</dd>
<dt>ObjData2</dt><dd><p>A weight associated with the <a class="reference internal" href="#objective2"><span class="std std-ref">second objective</span></a>. See <a class="reference internal" href="#objdata1"><span class="std std-ref">ObjData1</span></a>.</p>
</dd>
<dt>ObjData3</dt><dd><p>A weight associated with the <a class="reference internal" href="#objective3"><span class="std std-ref">third objective</span></a>. See <a class="reference internal" href="#objdata1"><span class="std std-ref">ObjData1</span></a>.</p>
</dd>
</dl>
<dl class="simple" id="objsort1">
<dt>Objsort1</dt><dd><p>Whether to maximize (<cite>True</cite>) or minimize (<cite>False</cite>) the <a class="reference internal" href="#objective1"><span class="std std-ref">first objective</span></a>.</p>
</dd>
<dt>Objsort2</dt><dd><p>Whether to maximize (<cite>True</cite>) or minimize (<cite>False</cite>) the <a class="reference internal" href="#objective2"><span class="std std-ref">second objective</span></a>.</p>
</dd>
<dt>Objsort3</dt><dd><p>Whether to maximize (<cite>True</cite>) or minimize (<cite>False</cite>) the <a class="reference internal" href="#objective3"><span class="std std-ref">third objective</span></a>.</p>
</dd>
</dl>
<dl id="searchrule">
<dt>SearchRule</dt><dd><p>The search rule allows users to par down the search space of technologies to those an
agent is likely to consider.
The search rule is any function with a given signature, and registered with MUSE via
<a class="reference internal" href="../source/muse.html#muse.filters.register_filter" title="muse.filters.register_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;register_filter</span></code></a>. The following search rules, defined
in <a class="reference internal" href="../source/muse.html#module-muse.filters" title="muse.filters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">filters</span></code></a>, are available with MUSE:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.same_enduse" title="muse.filters.same_enduse"><code class="xref py py-func docutils literal notranslate"><span class="pre">same_enduse</span></code></a>: Only allow technologies that provide the same
enduse as the current set of technologies owned by the agent.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.identity" title="muse.filters.identity"><code class="xref py py-func docutils literal notranslate"><span class="pre">identity</span></code></a>: Allows all current technologies. E.g. disables
filtering. Aliased to “all”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.similar_technology" title="muse.filters.similar_technology"><code class="xref py py-func docutils literal notranslate"><span class="pre">similar_technology</span></code></a>: Only allows technologies that
have the same type as current crop of technologies in the agent, as determined by
“tech_type” in <a class="reference internal" href="technodata.html#inputs-technodata"><span class="std std-ref">Techno-data</span></a>. Aliased to “similar”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.same_fuels" title="muse.filters.same_fuels"><code class="xref py py-func docutils literal notranslate"><span class="pre">same_fuels</span></code></a>: Only allows technologies that consume the same
fuels as the current crop of technologies in the agent. Aliased to
“fueltype”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.currently_existing_tech" title="muse.filters.currently_existing_tech"><code class="xref py py-func docutils literal notranslate"><span class="pre">currently_existing_tech</span></code></a>: Only allows
technologies that the agent already owns. Aliased to “existing”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.currently_referenced_tech" title="muse.filters.currently_referenced_tech"><code class="xref py py-func docutils literal notranslate"><span class="pre">currently_referenced_tech</span></code></a>: Only allows
technologies that are currently present in the market with non-zero capacity.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.filters.maturity" title="muse.filters.maturity"><code class="xref py py-func docutils literal notranslate"><span class="pre">maturity</span></code></a>: Only allows technologies that have achieved a given
market share.</p></li>
</ul>
<p>The implementation allows for combining these filters. However, the CSV data format
described here does not.</p>
</dd>
</dl>
<dl id="decisionmethod">
<dt>DecisionMethod</dt><dd><p>Decision methods reduce multiple objectives into a single scalar objective per
replacement technology. They allow combining several objectives into a single metric
through which replacement technologies can be ranked.</p>
<p>Decision methods are any function which follow a given signature and are registered
via the decorator <a class="reference internal" href="../source/muse.html#muse.decisions.register_decision" title="muse.decisions.register_decision"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;register_decision</span></code></a>. The following
decision methods are available with MUSE, as implemented in
<a class="reference internal" href="../source/muse.html#module-muse.decisions" title="muse.decisions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decisions</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.mean" title="muse.decisions.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean</span></code></a>: Computes the average across several objectives.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.weighted_sum" title="muse.decisions.weighted_sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">weighted_sum</span></code></a>: Computes a weighted average across several
objectives.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.lexical_comparison" title="muse.decisions.lexical_comparison"><code class="xref py py-func docutils literal notranslate"><span class="pre">lexical_comparion</span></code></a>: Compares objectives using a
binned lexical comparison operator. Aliased to “lexo”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.retro_lexical_comparison" title="muse.decisions.retro_lexical_comparison"><code class="xref py py-func docutils literal notranslate"><span class="pre">retro_lexical_comparion</span></code></a>: A binned lexical
comparison function where the bin size is adjusted to ensure the current crop of
technologies are competitive. Aliased to “retro_lexo”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.epsilon_constraints" title="muse.decisions.epsilon_constraints"><code class="xref py py-func docutils literal notranslate"><span class="pre">epsilon_constraints</span></code></a>: A comparison method which
ensures that first selects technologies following constraints on objectives 2 and
higher, before actually ranking them using objective 1. Aliased to “epsilon” ad
“epsilon_con”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.retro_epsilon_constraints" title="muse.decisions.retro_epsilon_constraints"><code class="xref py py-func docutils literal notranslate"><span class="pre">retro_epsilon_constraints</span></code></a>: A variation on
epsilon constraints which ensures that the current crop of technologies are not
deselected by the constraints. Aliased to “retro_epsilon”.</p></li>
<li><p><a class="reference internal" href="../source/muse.html#muse.decisions.single_objective" title="muse.decisions.single_objective"><code class="xref py py-func docutils literal notranslate"><span class="pre">single_objective</span></code></a>: A decision method to allow
ranking via a single objective.</p></li>
</ul>
<p>The functions allow for any number of objectives. However, the format described here
allows only for three.</p>
</dd>
<dt>Quantity</dt><dd><p>A factor used to determine the demand share of “New” agents.</p>
</dd>
<dt>MaturityThreshold</dt><dd><p>Parameter for the search rule <a class="reference internal" href="../source/muse.html#muse.filters.maturity" title="muse.filters.maturity"><code class="xref py py-func docutils literal notranslate"><span class="pre">maturity</span></code></a>.</p>
</dd>
</dl>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="existing_capacity.html"
                        title="previous chapter">Existing Sectoral Capacity</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="correlation_files.html"
                        title="next chapter">Correlation demand files</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/inputs/agents.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="correlation_files.html" title="Correlation demand files"
             >next</a> |</li>
        <li class="right" >
          <a href="existing_capacity.html" title="Existing Sectoral Capacity"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MUSE Documentation 0.8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Input Files</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="inputs_csv.html" >Input Files</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Agents</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Sustainable Gas Institute.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>